import { context as apiContext, diag, trace, } from "@opentelemetry/api";
import { FISpan } from "./FISpan";
import { generateTraceConfig } from "./traceConfig";
import { getAttributesFromContext } from "../contextAttributes";
/**
 * Formats the params for the startActiveSpan method
 * The method has multiple overloads, so we need to format the arguments
 * Taken from @see https://github.com/open-telemetry/opentelemetry-js/blob/main/packages/opentelemetry-sdk-trace-base/src/Tracer.ts#L220C3-L235C6
 *
 */
function formatStartActiveSpanParams(arg2, arg3, arg4) {
    let opts;
    let ctx;
    let fn;
    if (typeof arg2 === "function") {
        fn = arg2;
    }
    else if (typeof arg3 === "function") {
        opts = arg2;
        fn = arg3;
    }
    else {
        opts = arg2;
        ctx = arg3;
        fn = arg4;
    }
    opts = opts ?? {};
    ctx = ctx ?? apiContext.active();
    return { opts, ctx, fn };
}
/**
 * A wrapper around the OpenTelemetry {@link Tracer} interface that masks sensitive information based on the passed in {@link TraceConfig}.
 */
export class FITracer {
    /**
     *
     * @param tracer The OpenTelemetry {@link Tracer} to wrap
     * @param traceConfig The {@link TraceConfigOptions} to set to control the behavior of the tracer
     */
    constructor({ tracer, traceConfig, }) {
        this.tracer = tracer;
        this.config = generateTraceConfig(traceConfig);
        // ADDED LOG
        // diag.debug(
        //   `FITracer CONSTRUCTOR: Received tracer type: ${tracer?.constructor?.name}. TraceConfig provided: ${!!traceConfig}`
        // );
    }
    startActiveSpan(name, arg2, arg3, arg4) {
        const formattedArgs = formatStartActiveSpanParams(arg2, arg3, arg4);
        if (formattedArgs == null) {
            return;
        }
        const { opts, ctx, fn } = formattedArgs;
        const { attributes } = opts ?? {};
        const contextAttributes = getAttributesFromContext(ctx);
        const mergedAttributes = { ...contextAttributes, ...attributes };
        return this.tracer.startActiveSpan(name, { ...opts, attributes: undefined }, ctx, (span) => {
            const fiSpan = new FISpan({
                span,
                config: this.config,
            });
            fiSpan.setAttributes(mergedAttributes);
            return fn(fiSpan);
        });
    }
    startSpan(name, options, context) {
        // ADDED LOG
        // diag.debug(
        //     `FITracer.startSpan CALLED for name: "${name}". Internal this.tracer type: ${this.tracer?.constructor?.name}`
        // );
        if (!this.tracer || this.tracer.constructor.name === "NoopTracer") {
            diag.warn(`FITracer.startSpan: Internal tracer is NoopTracer or null. Returning NoopSpan for "${name}".`);
            // Return an actual NoopSpan from the API to avoid downstream errors if this path is taken.
            const noopOtelSpan = trace.getTracer("fi-noop-tracer-internal").startSpan(name, options, context);
            return new FISpan({ span: noopOtelSpan, config: this.config });
        }
        const { attributes: originalAttributes, ...otherOptions } = options ?? {};
        const span = this.tracer.startSpan(name, { ...otherOptions, attributes: originalAttributes }, context);
        // ADDED LOGS - CRITICAL
        const spanContext = span.spanContext();
        const isNoOp = spanContext.traceFlags === 0 && spanContext.spanId === '0000000000000000';
        // diag.debug(
        //   `FITracer.startSpan: OTel tracer (${this.tracer?.constructor?.name}) created span. ID: ${spanContext.spanId}, TraceID: ${spanContext.traceId}, TraceFlags: ${spanContext.traceFlags}, Is NoOp: ${isNoOp}`
        // );
        return new FISpan({ span, config: this.config });
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRklUcmFjZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJGSVRyYWNlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0gsT0FBTyxJQUFJLFVBQVUsRUFNckIsSUFBSSxFQUNKLEtBQUssR0FDTixNQUFNLG9CQUFvQixDQUFDO0FBTTVCLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFDbEMsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3BELE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBRWhFOzs7OztHQUtHO0FBQ0gsU0FBUywyQkFBMkIsQ0FDbEMsSUFBc0IsRUFDdEIsSUFBa0IsRUFDbEIsSUFBUTtJQUVSLElBQUksSUFBNkIsQ0FBQztJQUNsQyxJQUFJLEdBQXdCLENBQUM7SUFDN0IsSUFBSSxFQUFLLENBQUM7SUFFVixJQUFJLE9BQU8sSUFBSSxLQUFLLFVBQVUsRUFBRSxDQUFDO1FBQy9CLEVBQUUsR0FBRyxJQUFJLENBQUM7SUFDWixDQUFDO1NBQU0sSUFBSSxPQUFPLElBQUksS0FBSyxVQUFVLEVBQUUsQ0FBQztRQUN0QyxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ1osRUFBRSxHQUFHLElBQUksQ0FBQztJQUNaLENBQUM7U0FBTSxDQUFDO1FBQ04sSUFBSSxHQUFHLElBQUksQ0FBQztRQUNaLEdBQUcsR0FBRyxJQUFJLENBQUM7UUFDWCxFQUFFLEdBQUcsSUFBUyxDQUFDO0lBQ2pCLENBQUM7SUFFRCxJQUFJLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQztJQUNsQixHQUFHLEdBQUcsR0FBRyxJQUFJLFVBQVUsQ0FBQyxNQUFNLEVBQUUsQ0FBQztJQUVqQyxPQUFPLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsQ0FBQztBQUMzQixDQUFDO0FBRUQ7O0dBRUc7QUFDSCxNQUFNLE9BQU8sUUFBUTtJQUduQjs7OztPQUlHO0lB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RUFBRSxDQUFDLENBQUM7SUFDbkQsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBjb250ZXh0IGFzIGFwaUNvbnRleHQsXG4gICAgY29udGV4dCxcbiAgICBDb250ZXh0LFxuICAgIFNwYW4sXG4gICAgU3Bhbk9wdGlvbnMsXG4gICAgVHJhY2VyLFxuICAgIGRpYWcsXG4gICAgdHJhY2UsXG4gIH0gZnJvbSBcIkBvcGVudGVsZW1ldHJ5L2FwaVwiO1xuICBpbXBvcnQge1xuICAgIEZJQWN0aXZlU3BhbkNhbGxiYWNrLFxuICAgIFRyYWNlQ29uZmlnLFxuICAgIFRyYWNlQ29uZmlnT3B0aW9ucyxcbiAgfSBmcm9tIFwiLi90eXBlc1wiO1xuICBpbXBvcnQgeyBGSVNwYW4gfSBmcm9tIFwiLi9GSVNwYW5cIjtcbiAgaW1wb3J0IHsgZ2VuZXJhdGVUcmFjZUNvbmZpZyB9IGZyb20gXCIuL3RyYWNlQ29uZmlnXCI7XG4gIGltcG9ydCB7IGdldEF0dHJpYnV0ZXNGcm9tQ29udGV4dCB9IGZyb20gXCIuLi9jb250ZXh0QXR0cmlidXRlc1wiO1xuICBcbiAgLyoqXG4gICAqIEZvcm1hdHMgdGhlIHBhcmFtcyBmb3IgdGhlIHN0YXJ0QWN0aXZlU3BhbiBtZXRob2RcbiAgICogVGhlIG1ldGhvZCBoYXMgbXVsdGlwbGUgb3ZlcmxvYWRzLCBzbyB3ZSBuZWVkIHRvIGZvcm1hdCB0aGUgYXJndW1lbnRzXG4gICAqIFRha2VuIGZyb20gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vb3Blbi10ZWxlbWV0cnkvb3BlbnRlbGVtZXRyeS1qcy9ibG9iL21haW4vcGFja2FnZXMvb3BlbnRlbGVtZXRyeS1zZGstdHJhY2UtYmFzZS9zcmMvVHJhY2VyLnRzI0wyMjBDMy1MMjM1QzZcbiAgICpcbiAgICovXG4gIGZ1bmN0aW9uIGZvcm1hdFN0YXJ0QWN0aXZlU3BhblBhcmFtczxGIGV4dGVuZHMgRklBY3RpdmVTcGFuQ2FsbGJhY2s+KFxuICAgIGFyZzI/OiBTcGFuT3B0aW9ucyB8IEYsXG4gICAgYXJnMz86IENvbnRleHQgfCBGLFxuICAgIGFyZzQ/OiBGLFxuICApIHtcbiAgICBsZXQgb3B0czogU3Bhbk9wdGlvbnMgfCB1bmRlZmluZWQ7XG4gICAgbGV0IGN0eDogQ29udGV4dCB8IHVuZGVmaW5lZDtcbiAgICBsZXQgZm46IEY7XG4gIFxuICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBmbiA9IGFyZzI7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBvcHRzID0gYXJnMjtcbiAgICAgIGZuID0gYXJnMztcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0cyA9IGFyZzI7XG4gICAgICBjdHggPSBhcmczO1xuICAgICAgZm4gPSBhcmc0IGFzIEY7XG4gICAgfVxuICBcbiAgICBvcHRzID0gb3B0cyA/PyB7fTtcbiAgICBjdHggPSBjdHggPz8gYXBpQ29udGV4dC5hY3RpdmUoKTtcbiAgXG4gICAgcmV0dXJuIHsgb3B0cywgY3R4LCBmbiB9O1xuICB9XG4gIFxuICAvKipcbiAgICogQSB3cmFwcGVyIGFyb3VuZCB0aGUgT3BlblRlbGVtZXRyeSB7QGxpbmsgVHJhY2VyfSBpbnRlcmZhY2UgdGhhdCBtYXNrcyBzZW5zaXRpdmUgaW5mb3JtYXRpb24gYmFzZWQgb24gdGhlIHBhc3NlZCBpbiB7QGxpbmsgVHJhY2VDb25maWd9LlxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIEZJVHJhY2VyIGltcGxlbWVudHMgVHJhY2VyIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRyYWNlcjogVHJhY2VyO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgY29uZmlnOiBUcmFjZUNvbmZpZztcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0cmFjZXIgVGhlIE9wZW5UZWxlbWV0cnkge0BsaW5rIFRyYWNlcn0gdG8gd3JhcFxuICAgICAqIEBwYXJhbSB0cmFjZUNvbmZpZyBUaGUge0BsaW5rIFRyYWNlQ29uZmlnT3B0aW9uc30gdG8gc2V0IHRvIGNvbnRyb2wgdGhlIGJlaGF2aW9yIG9mIHRoZSB0cmFjZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7XG4gICAgICB0cmFjZXIsXG4gICAgICB0cmFjZUNvbmZpZyxcbiAgICB9OiB7XG4gICAgICB0cmFjZXI6IFRyYWNlcjtcbiAgICAgIHRyYWNlQ29uZmlnPzogVHJhY2VDb25maWdPcHRpb25zO1xuICAgIH0pIHtcbiAgICAgIHRoaXMudHJhY2VyID0gdHJhY2VyO1xuICAgICAgdGhpcy5jb25maWcgPSBnZW5lcmF0ZVRyYWNlQ29uZmlnKHRyYWNlQ29uZmlnKTtcbiAgICAgIC8vIEFEREVEIExPR1xuICAgICAgLy8gZGlhZy5kZWJ1ZyhcbiAgICAgIC8vICAgYEZJVHJhY2VyIENPTlNUUlVDVE9SOiBSZWNlaXZlZCB0cmFjZXIgdHlwZTogJHt0cmFjZXI/LmNvbnN0cnVjdG9yPy5uYW1lfS4gVHJhY2VDb25maWcgcHJvdmlkZWQ6ICR7ISF0cmFjZUNvbmZpZ31gXG4gICAgICAvLyApO1xuICAgIH1cbiAgICBzdGFydEFjdGl2ZVNwYW48RiBleHRlbmRzIChzcGFuOiBGSVNwYW4pID0+IHVua25vd24+KFxuICAgICAgbmFtZTogc3RyaW5nLFxuICAgICAgZm46IEYsXG4gICAgKTogUmV0dXJuVHlwZTxGPjtcbiAgICBzdGFydEFjdGl2ZVNwYW48RiBleHRlbmRzIChzcGFuOiBGSVNwYW4pID0+IHVua25vd24+KFxuICAgICAgbmFtZTogc3RyaW5nLFxuICAgICAgb3B0aW9uczogU3Bhbk9wdGlvbnMsXG4gICAgICBmbjogRixcbiAgICApOiBSZXR1cm5UeXBlPEY+O1xuICAgIHN0YXJ0QWN0aXZlU3BhbjxGIGV4dGVuZHMgKHNwYW46IEZJU3BhbikgPT4gdW5rbm93bj4oXG4gICAgICBuYW1lOiBzdHJpbmcsXG4gICAgICBvcHRpb25zOiBTcGFuT3B0aW9ucyxcbiAgICAgIGNvbnRleHQ6IENvbnRleHQsXG4gICAgICBmbjogRixcbiAgICApOiBSZXR1cm5UeXBlPEY+O1xuICAgIHN0YXJ0QWN0aXZlU3BhbjxGIGV4dGVuZHMgKHNwYW46IEZJU3BhbikgPT4gUmV0dXJuVHlwZTxGPj4oXG4gICAgICBuYW1lOiBzdHJpbmcsXG4gICAgICBhcmcyPzogRiB8IFNwYW5PcHRpb25zLFxuICAgICAgYXJnMz86IEYgfCBDb250ZXh0LFxuICAgICAgYXJnND86IEYsXG4gICAgKTogUmV0dXJuVHlwZTxGPiB8IHVuZGVmaW5lZCB7XG4gICAgICBjb25zdCBmb3JtYXR0ZWRBcmdzID0gZm9ybWF0U3RhcnRBY3RpdmVTcGFuUGFyYW1zKGFyZzIsIGFyZzMsIGFyZzQpO1xuICAgICAgaWYgKGZvcm1hdHRlZEFyZ3MgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7IG9wdHMsIGN0eCwgZm4gfSA9IGZvcm1hdHRlZEFyZ3M7XG4gICAgICBjb25zdCB7IGF0dHJpYnV0ZXMgfSA9IG9wdHMgPz8ge307XG4gICAgICBjb25zdCBjb250ZXh0QXR0cmlidXRlcyA9IGdldEF0dHJpYnV0ZXNGcm9tQ29udGV4dChjdHgpO1xuICAgICAgY29uc3QgbWVyZ2VkQXR0cmlidXRlcyA9IHsgLi4uY29udGV4dEF0dHJpYnV0ZXMsIC4uLmF0dHJpYnV0ZXMgfTtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNlci5zdGFydEFjdGl2ZVNwYW4oXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHsgLi4ub3B0cywgYXR0cmlidXRlczogdW5kZWZpbmVkIH0sXG4gICAgICAgIGN0eCxcbiAgICAgICAgKHNwYW46IFNwYW4pID0+IHtcbiAgICAgICAgICBjb25zdCBmaVNwYW4gPSBuZXcgRklTcGFuKHtcbiAgICAgICAgICAgIHNwYW4sXG4gICAgICAgICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZpU3Bhbi5zZXRBdHRyaWJ1dGVzKG1lcmdlZEF0dHJpYnV0ZXMpO1xuICAgICAgICAgIHJldHVybiBmbihmaVNwYW4pO1xuICAgICAgICB9LFxuICAgICAgKTtcbiAgICB9XG4gIFxuICAgIHN0YXJ0U3BhbihuYW1lOiBzdHJpbmcsIG9wdGlvbnM/OiBTcGFuT3B0aW9ucywgY29udGV4dD86IENvbnRleHQpOiBGSVNwYW4ge1xuICAgICAgLy8gQURERUQgTE9HXG4gICAgICAgIC8vIGRpYWcuZGVidWcoXG4gICAgICAgIC8vICAgICBgRklUcmFjZXIuc3RhcnRTcGFuIENBTExFRCBmb3IgbmFtZTogXCIke25hbWV9XCIuIEludGVybmFsIHRoaXMudHJhY2VyIHR5cGU6ICR7dGhpcy50cmFjZXI/LmNvbnN0cnVjdG9yPy5uYW1lfWBcbiAgICAgICAgLy8gKTtcblxuICAgICAgaWYgKCF0aGlzLnRyYWNlciB8fCB0aGlzLnRyYWNlci5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIk5vb3BUcmFjZXJcIikge1xuICAgICAgICBkaWFnLndhcm4oXG4gICAgICAgICAgYEZJVHJhY2VyLnN0YXJ0U3BhbjogSW50ZXJuYWwgdHJhY2VyIGlzIE5vb3BUcmFjZXIgb3IgbnVsbC4gUmV0dXJuaW5nIE5vb3BTcGFuIGZvciBcIiR7bmFtZX1cIi5gXG4gICAgICAgICk7XG4gICAgICAgIC8vIFJldHVybiBhbiBhY3R1YWwgTm9vcFNwYW4gZnJvbSB0aGUgQVBJIHRvIGF2b2lkIGRvd25zdHJlYW0gZXJyb3JzIGlmIHRoaXMgcGF0aCBpcyB0YWtlbi5cbiAgICAgICAgY29uc3Qgbm9vcE90ZWxTcGFuID0gdHJhY2UuZ2V0VHJhY2VyKFwiZmktbm9vcC10cmFjZXItaW50ZXJuYWxcIikuc3RhcnRTcGFuKG5hbWUsIG9wdGlvbnMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gbmV3IEZJU3Bhbih7IHNwYW46IG5vb3BPdGVsU3BhbiwgY29uZmlnOiB0aGlzLmNvbmZpZyB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgeyBhdHRyaWJ1dGVzOiBvcmlnaW5hbEF0dHJpYnV0ZXMsIC4uLm90aGVyT3B0aW9ucyB9ID0gb3B0aW9ucyA/PyB7fTtcblxuICAgICAgY29uc3Qgc3BhbiA9IHRoaXMudHJhY2VyLnN0YXJ0U3BhbihcbiAgICAgICAgbmFtZSxcbiAgICAgICAgeyAuLi5vdGhlck9wdGlvbnMsIGF0dHJpYnV0ZXM6IG9yaWdpbmFsQXR0cmlidXRlcyB9LFxuICAgICAgICBjb250ZXh0LFxuICAgICAgKTtcblxuICAgICAgLy8gQURERUQgTE9HUyAtIENSSVRJQ0FMXG4gICAgICBjb25zdCBzcGFuQ29udGV4dCA9IHNwYW4uc3BhbkNvbnRleHQoKTtcbiAgICAgIGNvbnN0IGlzTm9PcCA9IHNwYW5Db250ZXh0LnRyYWNlRmxhZ3MgPT09IDAgJiYgc3BhbkNvbnRleHQuc3BhbklkID09PSAnMDAwMDAwMDAwMDAwMDAwMCc7XG4gICAgICAvLyBkaWFnLmRlYnVnKFxuICAgICAgLy8gICBgRklUcmFjZXIuc3RhcnRTcGFuOiBPVGVsIHRyYWNlciAoJHt0aGlzLnRyYWNlcj8uY29uc3RydWN0b3I/Lm5hbWV9KSBjcmVhdGVkIHNwYW4uIElEOiAke3NwYW5Db250ZXh0LnNwYW5JZH0sIFRyYWNlSUQ6ICR7c3BhbkNvbnRleHQudHJhY2VJZH0sIFRyYWNlRmxhZ3M6ICR7c3BhbkNvbnRleHQudHJhY2VGbGFnc30sIElzIE5vT3A6ICR7aXNOb09wfWBcbiAgICAgIC8vICk7XG4gICAgICBcbiAgICAgIHJldHVybiBuZXcgRklTcGFuKHsgc3BhbiwgY29uZmlnOiB0aGlzLmNvbmZpZyB9KTtcbiAgICB9XG4gIH0iXX0=